# -*- coding: utf-8 -*-
"""QUICK 13_CalculatingMissingValuesBtwHourBeforeSepsisOnset-ShockOnset.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15zFoQcPNAgIIz8ywi54ljKs9iKmiiNBj
"""

# Commented out IPython magic to ensure Python compatibility.

!pip install wfdb
import io
import pandas as pd
from IPython.display import display
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np
import os
import shutil
import posixpath
import wfdb
import urllib.request
import datetime
from collections import namedtuple

from google.colab import files
uploaded = files.upload()

df_csvdata = pd.read_csv(io.BytesIO(uploaded['new_df_waveform_exists.csv']))
# Dataset is now stored in a Pandas Dataframe
print ('shape of original dataframe from CSV : ', df_csvdata.shape)
print(df_csvdata.columns)

df_csvdata = df_csvdata[df_csvdata['sepsis_onsettime'].notna() ]

df_csvdata['4HoursBeforeSepsis_outtime_percentNonMissingData']=''; 
df_csvdata['3HoursBeforeSepsis_outtime_percentNonMissingData']='';

df_csvdata['2HoursBeforeSepsis_outtime_percentNonMissingData']=''; 

df_csvdata['1HoursBeforeSepsis_outtime_percentNonMissingData']='';

df_csvdata['Sepsis_outtime_percentNonMissingData']=''; 

df_csvdata['4HourBefore_1hourAfter_SepsisShock_percentNonMissingData']='';

df_csvdata['3HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=''; 

df_csvdata['2HourBefore_1hourAfter_SepsisShock_percentNonMissingData']='';

df_csvdata['1HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=''; 

df_csvdata['gap']='';

print ('Shape of dataframe with only ICU stays for whom the signals and time overlap exists : ',df_csvdata.shape )
print (df_csvdata.columns)
print(df_csvdata)

df_csvdata = df_csvdata[df_csvdata['subject_id']==81480]
print(df_csvdata)

#df_ts_records_columns = ['RECORD','TIME','HR', 'SPO2','ABPSYS','ABPDIAS','ABPMEAN','RESP'] 
df_ts_records_columns = ['SUBJECT_ID','ICUSTAY_ID','RECORD','TIME','HR', 'SPO2','ABPSYS','ABPDIAS','ABPMEAN','RESP'] 
#df_ts_records_all_patients_columns =  ['SUBJECT_ID','ICUSTAY_ID','RECORD','TIME','HR', 'SPO2','ABPSYS','ABPDIAS','ABPMEAN','RESP']  # main DF for extracting TS of ALL patients
#df_ts_records_all_patients = pd.DataFrame(columns=df_ts_records_all_patients_columns)


for idx, row in df_csvdata.iterrows():
    #print(row['subject_id']);
    try:
      df_ts_records.drop(df_ts_records.index,inplace=True)
    except:
      print('MAIN DF does not exits')

    df_ts_records = pd.DataFrame(columns=df_ts_records_columns);

    wdb_dir_path = 'mimic3wdb/matched/p'+ str(row['subject_id']).zfill(6)[:2] + '/p' + str(row['subject_id']).zfill(6) + '/';
    wdb_path_toAllRecords = 'https://archive.physionet.org/physiobank/database/'+ wdb_dir_path + 'RECORDS';
    wdb_records =  urllib.request.urlopen(wdb_path_toAllRecords);   
    count_overlap = 0; 
    gap = ''; 
    for lines in wdb_records.readlines():
      record = lines.decode("utf-8"); 
      record = str(record).rstrip()
      #print (record[-1:])
      if record[-1:] == 'n':
        #print(record);
        #print (wdb_dir_path);
        consider_record =0 ;
        record = str(record).rstrip()

        try:
          signals =''
          fields = ''
          #print(wdb_dir_path)
          #print(record)
          signals,fields = wfdb.rdsamp(record, pn_dir=wdb_dir_path) ; 
          list_sig_name = [item.upper().replace(' ','') for item in fields['sig_name']]
          sig_exist_1 = all(x in list_sig_name for x in ['HR', 'SPO2','ABPSYS','ABPDIAS','ABPMEAN','RESP']);  #%SpO2
          sig_exist_2 = all(x in list_sig_name for x in ['HR', '%SPO2','ABPSYS','ABPDIAS','ABPMEAN','RESP']); 
          if ((sig_exist_1 == True) or (sig_exist_2 == True)) :
            consider_record = 1
          else:
            consider_record = 0
          record_starttime = datetime.datetime.combine(fields['base_date'] ,fields['base_time'] ) ;
          if  '%.3f'%(fields['fs']) == '1.000' :
            record_endtime = record_starttime + datetime.timedelta(seconds= (fields['sig_len']-1)) ;
          elif '%.3f'%(fields['fs'])== '0.017' :
            record_endtime = record_starttime + datetime.timedelta(minutes = (fields['sig_len']-1)) ;
          else : 
            print('ERROR IN SAMPLING');
            print(record);
            print(wdb_dir_path);
          #Caculate if we have a recording for the time of icu stay
          Range = namedtuple('Range', ['start', 'end'])

          fourHours_before_SepsisOnset = '';
          outime_orShockTime = '' ;

          fourHours_before_SepsisOnset = (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 4));

          if ( str(row['sepstic_shock_onsettime']) != 'nan' ) and (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') > datetime.datetime.strptime(row['outtime'],'%Y-%m-%d %H:%M:%S')):
            outime_orShockTime  = datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1) ;
          else:
            outime_orShockTime  = datetime.datetime.strptime(row['outtime'],'%Y-%m-%d %H:%M:%S') ;

          r1 = Range(start= fourHours_before_SepsisOnset , end= outime_orShockTime)

          r2 = Range(start= record_starttime, end = record_endtime)

          latest_start = max(r1.start, r2.start)
          earliest_end = min(r1.end, r2.end)
          delta = (earliest_end - latest_start).days + 1
          df_row_idx = df_ts_records.shape[0] ;
          
          if ( ((r1.start <= r2.end) and (r2.start <= r1.end) ) and (consider_record ==1) ):
          #if ((delta >= 0 ) & (consider_record ==1)) :
            ###
            try:
              df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True)
            except:
              print('individual record for a single patient df does not exists')
              
            df_ts_indv_record_temp = pd.DataFrame(columns = df_ts_records_columns ) # individual record for a single patient #safiya
            ###
            #print('RECORD EXISTS FOR THE ICU STAYS WITH THE SIGNALS NEEDED : ', row['subject_id'])
            #df_csvdata.loc[idx,'timeoverlap'] = 1;
            #todo : adding new dataframe, exatracting required signals, computing avergage for per sminute values in case of per second sampling frequency
            for i in fields['sig_name']:
              if i.upper().replace(' ','') == 'HR':
                idx_HR='';
                idx_HR = fields['sig_name'].index(i);
              elif (( i.upper().replace(' ','') == 'SPO2') or (i.upper().replace(' ','') =='%SPO2')):
                idx_SPO2 = '';
                idx_SPO2 = fields['sig_name'].index(i);
              elif i.upper().replace(' ','') == 'ABPSYS' :
                idx_ABPSYS = '';
                idx_ABPSYS = fields['sig_name'].index(i);
              elif i.upper().replace(' ','') == 'ABPDIAS' :
                idx_ABPDIAS = '';
                idx_ABPDIAS = fields['sig_name'].index(i);
              elif i.upper().replace(' ','') == 'ABPMEAN' :
                idx_ABPMEAN = '';
                idx_ABPMEAN = fields['sig_name'].index(i);
              elif i.upper().replace(' ','') == 'RESP' :
                idx_RESP = '';
                idx_RESP = fields['sig_name'].index(i);
                
            if count_overlap == 0 : 
              if record_starttime > fourHours_before_SepsisOnset:
                #print('inserting nulls between icu intime and record start time')
                minutes_to_insert_start = record_starttime - fourHours_before_SepsisOnset
                #print('minutes_to_insert_start:  ', minutes_to_insert_start)
                duration_in_s = minutes_to_insert_start.total_seconds()
                minutes_to_insert_start = divmod(duration_in_s, 60)[0] - 1 
                gap = gap + ',start:' + str(minutes_to_insert_start)

                try:
                  df_ts_records_time_temp_start.drop(df_ts_records_time_temp_start.index,  inplace=True)
                except :
                  print( 'df_ts_records_time_temp_start does not exist')

                df_ts_records_time_temp_start = pd.DataFrame(columns=df_ts_records_columns)

                if '%.3f'%(fields['fs'])== '0.017' :
                  df_ts_records_time_temp_start['TIME'] = pd.date_range(fourHours_before_SepsisOnset + datetime.timedelta(minutes=1), 
                                                              periods = minutes_to_insert_start, freq='1min'); 
                elif '%.3f'%(fields['fs'])== '1.000' :
                  df_ts_records_time_temp_start['TIME'] = pd.date_range(fourHours_before_SepsisOnset + datetime.timedelta(seconds=1), 
                                                              periods = (duration_in_s-1), freq='S');  
                df_ts_indv_record_temp = df_ts_indv_record_temp.append(df_ts_records_time_temp_start, ignore_index=True);

              try:
                df_ts_records_temp.drop(df_ts_records_temp.index,  inplace=True)
              except:
                print( 'df_ts_records_time_temp_start does not exist')

              df_ts_records_temp = pd.DataFrame(columns=df_ts_records_columns)
              df_ts_records_temp['HR']= signals[:,idx_HR ] 
              df_ts_records_temp['SPO2']= signals[:,idx_SPO2 ] 
              df_ts_records_temp['ABPSYS']= signals[:,idx_ABPSYS ] 
              df_ts_records_temp['ABPDIAS']= signals[:,idx_ABPDIAS ] 
              df_ts_records_temp['ABPMEAN']= signals[:,idx_ABPMEAN ] 
              df_ts_records_temp['RESP']= signals[:,idx_RESP ] 
              if '%.3f'%(fields['fs'])== '0.017' :
                df_ts_records_temp['TIME'] = pd.date_range(record_starttime, periods=fields['sig_len'], freq='1min'); 
              elif '%.3f'%(fields['fs'])== '1.000' :
                df_ts_records_temp['TIME'] = pd.date_range(record_starttime, periods=fields['sig_len'], freq='S'); 
              df_ts_records_temp.TIME = pd.to_datetime(df_ts_records_temp.TIME)
              df_ts_indv_record_temp = df_ts_indv_record_temp.append(df_ts_records_temp, ignore_index=True);
              df_ts_indv_record_temp['RECORD'] = record;

              #FOR FAST:
              df_ts_records = df_ts_records.append(df_ts_indv_record_temp, ignore_index=True);
              df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
              """

              if '%.3f'%(fields['fs'])== '1.000' : #safiya
                #print('shape of persecond data before aggregation: ', df_ts_indv_record_temp.shape)
                #print('aggregating first record')
                start_idx = 0;
                try:
                  df_ts_records_new.drop(df_ts_records_new.index, inplace=True)
                except:
                  print('df_ts_records_new does not exists')
                df_ts_records_new = pd.DataFrame(columns=df_ts_records_columns);
                #print('length of new df  '  , df_ts_records_new.shape[0] )
                for index, rows in df_ts_indv_record_temp.iterrows():
                  if start_idx >= df_ts_indv_record_temp.shape[0]:
                    exit;
                  else: 
                    #print(df_ts_records.iloc[start_idx: (start_idx+60), 2:8])
                    array = np.array( df_ts_indv_record_temp.iloc[start_idx: (start_idx+60), 4:10].mean(axis=0))
                    current_index = df_ts_records_new.shape[0]
                    df_ts_records_new.loc[current_index ,'HR']= array[0]
                    df_ts_records_new.loc[current_index,'SPO2']= array[1]
                    df_ts_records_new.loc[current_index,'ABPSYS']= array[2]
                    df_ts_records_new.loc[current_index,'ABPDIAS']= array[3]
                    df_ts_records_new.loc[current_index,'ABPMEAN']= array[4]
                    df_ts_records_new.loc[current_index,'RESP']= array[5]
                    start_idx = start_idx+60;

                #print('finished aggregating first record and now inserting into main df for a patient')
                df_ts_records_new['TIME'] = pd.date_range(df_ts_indv_record_temp.loc[0,'TIME'], periods= df_ts_records_new.shape[0], freq='1min'); 
                df_ts_records_new.TIME = pd.to_datetime(df_ts_records_new.TIME)
                df_ts_records_new['RECORD'] = record
                df_ts_records = df_ts_records.append(df_ts_records_new, ignore_index=True); # appending at one subject level
                df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
                df_ts_records_new.drop(df_ts_records_new.index, inplace=True)   
                #print('finished aggregating first record')

              else:
                df_ts_records = df_ts_records.append(df_ts_indv_record_temp, ignore_index=True);
                df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
              """
                

            else: # when it is a second/ third/... record for one subject
              if record_starttime < outime_orShockTime :
                last_Record_time = df_ts_records.loc[(df_row_idx-1),'TIME']
                #print('main DF last time record: ',last_Record_time )
                minutes_to_insert = record_starttime - last_Record_time
                duration_in_s = minutes_to_insert.total_seconds()
                minutes_to_insert = divmod(duration_in_s, 60)[0] - 1
                gap = gap + ',mid:' + str(minutes_to_insert)
                #print ('minutes_to_insert:  ', minutes_to_insert);
                try:
                  df_ts_records_time_temp.drop(df_ts_records_time_temp.index, inplace= True);
                  df_ts_records_temp.drop(df_ts_records_temp.index, inplace=True);
                except:
                  print ('df_ts_records_temp and df_ts_records_time_temp does not exits')
                df_ts_records_time_temp = pd.DataFrame(columns=df_ts_records_columns)
                if '%.3f'%(fields['fs'])== '0.017' :
                  df_ts_records_time_temp['TIME'] = pd.date_range(last_Record_time + datetime.timedelta(minutes=1), 
                                                              periods=minutes_to_insert, freq='1min'); 
                elif '%.3f'%(fields['fs'])== '1.000' :
                  df_ts_records_time_temp['TIME'] = pd.date_range(last_Record_time + datetime.timedelta(seconds=1), 
                                                              periods=(duration_in_s-1), freq='S'); 
                #print ('df_ts_records_time_temp:')
                #print (df_ts_records_time_temp)
                df_ts_indv_record_temp = df_ts_indv_record_temp.append(df_ts_records_time_temp, ignore_index=True);
              
                df_ts_records_temp = pd.DataFrame(columns=df_ts_records_columns)
                df_ts_records_temp['HR']= signals[:,idx_HR ] 
                df_ts_records_temp['SPO2']= signals[:,idx_SPO2 ] 
                df_ts_records_temp['ABPSYS']= signals[:,idx_ABPSYS ] 
                df_ts_records_temp['ABPDIAS']= signals[:,idx_ABPDIAS ] 
                df_ts_records_temp['ABPMEAN']= signals[:,idx_ABPMEAN ] 
                df_ts_records_temp['RESP']= signals[:,idx_RESP ] 
                if '%.3f'%(fields['fs'])== '0.017' :
                  df_ts_records_temp['TIME'] = pd.date_range(record_starttime, periods=fields['sig_len'], freq='1min'); 
                elif  '%.3f'%(fields['fs'])== '1.000' :
                  df_ts_records_temp['TIME'] = pd.date_range(record_starttime, periods=fields['sig_len'], freq='S'); 
                df_ts_records_temp.TIME = pd.to_datetime(df_ts_records_temp.TIME)
                df_ts_indv_record_temp = df_ts_indv_record_temp.append(df_ts_records_temp, ignore_index=True);
                df_ts_indv_record_temp['RECORD'] = record;
                
                #FOR FAST

                df_ts_records = df_ts_records.append(df_ts_indv_record_temp, ignore_index=True);
                df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
                
                """
                if '%.3f'%(fields['fs'])== '1.000' : #safiya
                  #print('aggregating second record')
                  start_idx = 0;
                  try:
                    df_ts_records_new.drop(df_ts_records_new.index, inplace=True)
                  except:
                    print('df_ts_records_new does not exists')
                  df_ts_records_new = pd.DataFrame(columns=df_ts_records_columns);
                  #print('length of new df  '  , df_ts_records_new.shape[0] )
                  for index, rows in df_ts_indv_record_temp.iterrows():
                    if start_idx >= df_ts_indv_record_temp.shape[0]:
                      exit;
                    else: 
                      array = np.array( df_ts_indv_record_temp.iloc[start_idx: (start_idx+60), 4:10].mean(axis=0))
                      current_index = df_ts_records_new.shape[0]
                      df_ts_records_new.loc[current_index ,'HR']= array[0]
                      df_ts_records_new.loc[current_index,'SPO2']= array[1]
                      df_ts_records_new.loc[current_index,'ABPSYS']= array[2]
                      df_ts_records_new.loc[current_index,'ABPDIAS']= array[3]
                      df_ts_records_new.loc[current_index,'ABPMEAN']= array[4]
                      df_ts_records_new.loc[current_index,'RESP']= array[5]
                      start_idx = start_idx+60;
                  
                  #print('finished aggregating second record and now inserting into main df for a patient')
                  df_ts_records_new['TIME'] = pd.date_range(df_ts_indv_record_temp.loc[0,'TIME'], periods= df_ts_records_new.shape[0], freq='1min'); 
                  df_ts_records_new.TIME = pd.to_datetime(df_ts_records_new.TIME)
                  df_ts_records_new['RECORD'] = record;
                  #df_ts_records = pd.DataFrame(columns=df_ts_records_columns)
                  df_ts_records = df_ts_records.append(df_ts_records_new, ignore_index=True);
                  df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
                  df_ts_records_new.drop(df_ts_records_new.index, inplace=True)
                  #print('finished aggregating second record')

                else:
                  df_ts_records = df_ts_records.append(df_ts_indv_record_temp, ignore_index=True);
                  df_ts_indv_record_temp.drop(df_ts_indv_record_temp.index, inplace=True);
                """     

            
            FS = '%.3f'%(fields['fs'])
            #print(FS)
            count_overlap = count_overlap +1
          else:            
            print('RECORD DOES NOT EXISTS FOR THE ICU STAYS WITH THE SIGNALS NEEDED : ', row['subject_id'])
              #df_csvdata.loc[idx,'timeoverlap'] = 0;

        except ValueError:
          print('Error occured while reading waveform: ', record);


    #print((datetime.datetime.strptime(row['intime'],'%Y-%m-%d %H:%M:%S') ) + datetime.timedelta(hours=24))
    try:
      last_record_idx = df_ts_records.shape[0] - 1
      all_records_end_time = df_ts_records.loc[last_record_idx,'TIME']
      
      if (all_records_end_time < outime_orShockTime ):
        #print('INSERTING NULLS AT THE END')
        try:
          df_ts_records_time_temp_end.drop(df_ts_records_time_temp_end.index, inplace=True)
        except:
          print('df_ts_records_time_temp_end does not exists')
        #print('main DF last time record: ',last_Record_time )
        minutes_to_insert_end = outime_orShockTime - all_records_end_time
        duration_in_s = minutes_to_insert_end.total_seconds()
        minutes_to_insert_end = divmod(duration_in_s, 60)[0] - 1
        gap = gap + ',end:' + str(minutes_to_insert_end)
        df_ts_records_time_temp_end = pd.DataFrame(columns=df_ts_records_columns)

        if FS == '0.017' :
          df_ts_records_time_temp_end['TIME'] = pd.date_range(all_records_end_time + datetime.timedelta(minutes=1), 
                                                              periods=minutes_to_insert_end, freq='1min'); 
        elif FS == '1.000' :
          df_ts_records_time_temp_end['TIME'] = pd.date_range(all_records_end_time + datetime.timedelta(seconds=1), 
                                                              periods=(duration_in_s-1), freq='S'); 

        df_ts_records = df_ts_records.append(df_ts_records_time_temp_end, ignore_index=True);
        #print('appended to df_ts_records')
      
      #df_ts_records['RECORD'] = record
      df_csvdata.loc[idx,'gap'] = gap;
      df_ts_records['SUBJECT_ID'] = row['subject_id']
      df_ts_records['ICUSTAY_ID'] = row['icustay_id']

      
      total_rows_4HourBeforeSepsisOnset_outtime = df_ts_records[(df_ts_records['TIME'] >= fourHours_before_SepsisOnset) & (df_ts_records['TIME'] <= outime_orShockTime)].shape[0]
      total_rows_4HourBeforeSepsisOnset_outtime_notNAN = df_ts_records[(df_ts_records['TIME'] >=  fourHours_before_SepsisOnset) & (df_ts_records['TIME'] <= outime_orShockTime)].dropna().shape[0]
      percent_notNANdata_4hourbef_outtime = round(total_rows_4HourBeforeSepsisOnset_outtime_notNAN / total_rows_4HourBeforeSepsisOnset_outtime , 2) * 100 
      df_csvdata.loc[idx,'4HoursBeforeSepsis_outtime_percentNonMissingData'] = percent_notNANdata_4hourbef_outtime;

      total_rows_3HourBeforeSepsisOnset_outtime = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 3))) & (df_ts_records['TIME'] <= outime_orShockTime)].shape[0]
      total_rows_3HourBeforeSepsisOnset_outtime_notNAN = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 3))) & (df_ts_records['TIME'] <= outime_orShockTime)].dropna().shape[0]
      percent_notNANdata_3hourbef_outtime = round(total_rows_3HourBeforeSepsisOnset_outtime_notNAN / total_rows_3HourBeforeSepsisOnset_outtime , 2) * 100 
      df_csvdata.loc[idx,'3HoursBeforeSepsis_outtime_percentNonMissingData'] = percent_notNANdata_3hourbef_outtime;

      total_rows_2HourBeforeSepsisOnset_outtime = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 2)) ) & (df_ts_records['TIME'] <= outime_orShockTime)].shape[0]
      total_rows_2HourBeforeSepsisOnset_outtime_notNAN = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 2)) ) & (df_ts_records['TIME'] <= outime_orShockTime)].dropna().shape[0]
      percent_notNANdata_2hourbef_outtime = round(total_rows_2HourBeforeSepsisOnset_outtime_notNAN / total_rows_2HourBeforeSepsisOnset_outtime , 2) * 100 
      df_csvdata.loc[idx,'2HoursBeforeSepsis_outtime_percentNonMissingData'] = percent_notNANdata_2hourbef_outtime;

      total_rows_1HourBeforeSepsisOnset_outtime = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 1)) ) & (df_ts_records['TIME'] <= outime_orShockTime)].shape[0]
      total_rows_1HourBeforeSepsisOnset_outtime_notNAN = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 1)) ) & (df_ts_records['TIME'] <= outime_orShockTime)].dropna().shape[0]
      percent_notNANdata_1hourbef_outtime = round(total_rows_1HourBeforeSepsisOnset_outtime_notNAN / total_rows_1HourBeforeSepsisOnset_outtime , 2) * 100 
      df_csvdata.loc[idx,'1HoursBeforeSepsis_outtime_percentNonMissingData'] = percent_notNANdata_1hourbef_outtime;
 
      total_rows_afterSepsisOnset_outtime = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S') )) & (df_ts_records['TIME'] <= outime_orShockTime )].shape[0]
      total_rows_afterSepsisOnset_outtime_notNAN = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepsis_onsettime'],'%Y-%m-%d %H:%M:%S') )) & (df_ts_records['TIME'] <= outime_orShockTime)].dropna().shape[0]
      percent_notNANdata_afterSepsis_outtime = round(total_rows_afterSepsisOnset_outtime_notNAN / total_rows_afterSepsisOnset_outtime , 2) * 100 
      df_csvdata.loc[idx,'Sepsis_outtime_percentNonMissingData'] = percent_notNANdata_afterSepsis_outtime;
      

      if ( str(row['sepstic_shock_onsettime']) != 'nan' ) : 
        print('inseting for sepsis shock time');
        total_rows_4HourBefore_1hourafter_SepsisShock = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 4))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].shape[0]
        total_rows_4HourBefore_1hourafter_SepsisShock_notNAN = df_ts_records[(df_ts_records['TIME'] >=  (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 4))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].dropna().shape[0]
        percent_notNANdata_4HourBefore_1hourafter_SepsisShock = round(total_rows_4HourBefore_1hourafter_SepsisShock_notNAN / total_rows_4HourBefore_1hourafter_SepsisShock , 2) * 100 
        df_csvdata.loc[idx,'4HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] = percent_notNANdata_4HourBefore_1hourafter_SepsisShock;

        total_rows_3HourBefore_1hourafter_SepsisShock = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 3))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].shape[0]
        total_rows_3HourBefore_1hourafter_SepsisShock_notNAN = df_ts_records[(df_ts_records['TIME'] >=  (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 3))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].dropna().shape[0]
        percent_notNANdata_3HourBefore_1hourafter_SepsisShock = round(total_rows_3HourBefore_1hourafter_SepsisShock_notNAN / total_rows_3HourBefore_1hourafter_SepsisShock , 2) * 100 
        df_csvdata.loc[idx,'3HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] = percent_notNANdata_3HourBefore_1hourafter_SepsisShock;

        total_rows_2HourBefore_1hourafter_SepsisShock = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 2))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].shape[0]
        total_rows_2HourBefore_1hourafter_SepsisShock_notNAN = df_ts_records[(df_ts_records['TIME'] >=  (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 2))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].dropna().shape[0]
        percent_notNANdata_2HourBefore_1hourafter_SepsisShock = round(total_rows_2HourBefore_1hourafter_SepsisShock_notNAN / total_rows_2HourBefore_1hourafter_SepsisShock , 2) * 100 
        df_csvdata.loc[idx,'2HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] = percent_notNANdata_2HourBefore_1hourafter_SepsisShock;

        total_rows_1HourBefore_1hourafter_SepsisShock = df_ts_records[(df_ts_records['TIME'] >= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 1))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].shape[0]
        total_rows_1HourBefore_1hourafter_SepsisShock_notNAN = df_ts_records[(df_ts_records['TIME'] >=  (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S')  - datetime.timedelta(hours = 1))) & (df_ts_records['TIME'] <= (datetime.datetime.strptime(row['sepstic_shock_onsettime'],'%Y-%m-%d %H:%M:%S') + datetime.timedelta(hours = 1)))].dropna().shape[0]
        percent_notNANdata_1HourBefore_1hourafter_SepsisShock = round(total_rows_1HourBefore_1hourafter_SepsisShock_notNAN / total_rows_1HourBefore_1hourafter_SepsisShock , 2) * 100 
        df_csvdata.loc[idx,'1HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] = percent_notNANdata_1HourBefore_1hourafter_SepsisShock;

      #print(df_ts_records)

      #df_ts_records_all_patients = df_ts_records_all_patients.append(df_ts_records, ignore_index=True); # to insert into main df collecting TS of all patients
      #print('successfully inserted: ',row['subject_id'])
      
      
    except:
      print('hey nothing found ')
      #print('Error occured while reading waveform for patient: ', row['subject_id'])

pd.set_option('display.max_rows', 500)
pd.set_option('display.max_columns', 500)
pd.set_option('display.width', 1000)
print(df_csvdata)

df_csvdata['4HoursBeforeSepsis_outtime_percentNonMissingData']=df_csvdata['4HoursBeforeSepsis_outtime_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['3HoursBeforeSepsis_outtime_percentNonMissingData']=df_csvdata['3HoursBeforeSepsis_outtime_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['2HoursBeforeSepsis_outtime_percentNonMissingData']=df_csvdata['3HoursBeforeSepsis_outtime_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['1HoursBeforeSepsis_outtime_percentNonMissingData']=df_csvdata['1HoursBeforeSepsis_outtime_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['Sepsis_outtime_percentNonMissingData']=df_csvdata['Sepsis_outtime_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['4HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=df_csvdata['4HourBefore_1hourAfter_SepsisShock_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['3HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=df_csvdata['3HourBefore_1hourAfter_SepsisShock_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['2HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=df_csvdata['2HourBefore_1hourAfter_SepsisShock_percentNonMissingData'].apply(pd.to_numeric)

df_csvdata['1HourBefore_1hourAfter_SepsisShock_percentNonMissingData']=df_csvdata['1HourBefore_1hourAfter_SepsisShock_percentNonMissingData'].apply(pd.to_numeric)


print('count for more than equal to 80% non missing data between 4 hours before SEPSIS onset time and OUTTIME time: ', df_csvdata[(df_csvdata['4HoursBeforeSepsis_outtime_percentNonMissingData'] >= (80) ) ].shape[0]);

print('count for more than equal to 80% non missing data between 3 hours before SEPSIS onset time and OUTTIME time: ', df_csvdata[(df_csvdata['3HoursBeforeSepsis_outtime_percentNonMissingData'] >=(80) ) ].shape[0]);

print('count for more than equal to 80% non missing data between 2 hours before SEPSIS onset time and OUTTIME time: ', df_csvdata[(df_csvdata['2HoursBeforeSepsis_outtime_percentNonMissingData'] >=(80) ) ].shape[0]);

print('count for more than equal to 80% non missing data between 1 hours before SEPSIS onset time and OUTTIME time: ', df_csvdata[(df_csvdata['1HoursBeforeSepsis_outtime_percentNonMissingData'] >=(80) ) ].shape[0]);

print('count for more than equal to 80% non missing data between SEPSIS onset time and OUTTIME time: ', df_csvdata[(df_csvdata['Sepsis_outtime_percentNonMissingData'] >=(80) ) ].shape[0]);

print('#####################################################################################################################################')

print('count for more than equal to 80% non missing data between 4 hours before SHOCK onset time and SHOCK onset time PLUS 1 HOUR : ', df_csvdata[(df_csvdata['4HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] >=(80) ) ].shape[0]);
print('count for more than equal to 80% non missing data between 3 hours before SHOCK onset time and SHOCK onset time PLUS 1 HOUR : ', df_csvdata[(df_csvdata['3HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] >=(80) ) ].shape[0]);
print('count for more than equal to 80% non missing data between 2 hours before SHOCK onset time and SHOCK onset time PLUS 1 HOUR : ', df_csvdata[(df_csvdata['2HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] >=(80) ) ].shape[0]);
print('count for more than equal to 80% non missing data between 1 hours before SHOCK onset time and SHOCK onset time PLUS 1 HOUR : ', df_csvdata[(df_csvdata['1HourBefore_1hourAfter_SepsisShock_percentNonMissingData'] >=(80) ) ].shape[0]);

df_csvdata.to_csv ('FAST_df_sepsisPatients_%MissingValues_betwSepsisOnset_ShockOnset.csv', sep=',', index = False, header=True);

#df_ts_records_all_patients.to_csv ('FAST_df_TS_Data_sepsisPatients_betw_4hoursBefSepsisOnset_Outtime.csv', sep=',', index = False, header=True);

from google.colab import files
files.download('FAST_df_sepsisPatients_%MissingValues_betwSepsisOnset_ShockOnset.csv')

from google.colab import drive
drive.mount('/content/gdrive')

!cp "/content/FAST_df_TS_Data_sepsisPatients_betw_4hoursBefSepsisOnset_Outtime.csv" "/content/gdrive/My Drive/Master thesis"